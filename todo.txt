
ensure this is merged (C:\Users\Edward\Code\color-pallet-generator) ensure these styles are merged - oNLY THE oNES THAT ARE nEEDED!!! now ensure any RElEVANT styles from this are implemented, skip any not needed: /* / .home-page .feed-search { max-width: 900px; / match .feed / width: 100%; margin: 0 auto; / center / padding: clamp(0.25rem, 1vh, 0.75rem) clamp(12px, 4vw, 20px) 0; / match .feed side padding / box-sizing: border-box; / add spacing below search before the feed / margin-bottom: clamp(0.4rem, 1.8vw, 1rem); } .home-page .feed-search input[type="search"] { display: block; width: 100%; font-size: clamp(0.95rem, 3.5vw, 1.05rem); color: var(--text-color); background: transparent; border: 1px solid rgba(127,127,127,0.35); border-radius: 999px; / pill / padding: 0.6rem 0.9rem; outline: none; appearance: none; } / The native clear button is blue on some platforms. Replace it with a masked X colored by var(--text-color). / .home-page .feed-search input[type="search"]::-webkit-search-cancel-button { -webkit-appearance: none; height: 1.05em; width: 1.05em; background-color: var(--text-color); / X icon mask / -webkit-mask-image: url('data:image/svg+xml;utf8,<svg><path></path></svg>'); -webkit-mask-repeat: no-repeat; -webkit-mask-position: center; -webkit-mask-size: 100% 100%; cursor: pointer; opacity: 0.7; } .home-page .feed-search input[type="search"]:hover::-webkit-search-cancel-button, .home-page .feed-search input[type="search"]:focus::-webkit-search-cancel-button { opacity: 1; } .home-page .feed-search input[type="search"]::placeholder { color: var(--text-color); opacity: 0.55; / subtle / } .home-page .feed-search input[type="search"]:focus { border-color: rgba(127,127,127,0.6); outline: 2px solid rgba(127,127,127,0.4); outline-offset: 1px; } @media (prefers-color-scheme: dark) { .home-page .feed-search input[type="search"] { border-color: rgba(255,255,255,0.28); } .home-page .feed-search input[type="search"]:focus { border-color: rgba(255,255,255,0.55); outline-color: rgba(255,255,255,0.35); } } / 11) Responsive tweaks */ @media (max-width: 600px) { .legal-container return-home { margin-top: 1.5em; } .legal-container return-home .button { width: auto !important; min-width: 120px; font-size: 1em; } h1.massive { position: static; top: auto; left: auto; transform: none; margin-top: 2em; margin-bottom: 2em; } .legal-container { padding: 0.5em 0.2em; margin: 0.5em 0.1em; } .legal-container section { margin-bottom: 1.2em; } .legal-container h1 { font-size: clamp(1.2em, 5vw, 1.4em); margin-bottom: 20px; } .legal-container h2 { font-size: clamp(0.9em, 4vw, 1em); margin-bottom: 0.2em; } .legal-container p { font-size: clamp(0.8em, 3.5vw, 0.85em); margin-bottom: 0.1em; line-height: 1.4; } .topnav { gap: 0.5em; padding: 0.5em 0; font-size: 1em; overflow-x: visible; } .topnav a { padding: 0.5em 1em; } h1, h2 { text-align: left; } footer p { font-size: 0.9em; } a.button { width: 100%; box-sizing: border-box; font-size: 1em; } footer { padding: calc(var(--edge-vert-pad) * 0.86) 0 !important; min-height: 36px !important; font-size: 0.85em !important; } }
<meta></meta> <meta></meta> <title>Palette Generator</title> <link></link> <style><#data #data="<#data #data="<#data #data="<#data #data="<#data #data=" /* ------- layout ------- */ body {display:flex; flex-direction:column; min-height:100dvh;} /* container now stretches fully between header & footer */ .container{flex:1 1 auto; display:flex; flex-direction:column; padding:0; gap:0; min-height:0; position:relative; align-items:stretch; max-width:100vw;} .controls{position:absolute; top:0.5rem; left:50%; transform:translateX(-50%); z-index:3; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:.4rem; padding:0; pointer-events:none;} .kbd-hint{color:#666; font-size:.95rem; user-select:none; pointer-events:none;} .color-columns{flex:1 1 auto; display:flex; min-height:0; min-width:0; flex-direction: row; width:100%;} .color-col {flex:1; position:relative; cursor:copy; min-width:0;} <pre data-copilot-type="code-block" data-copilot-offset="31292,33493" data-copilot-code-block-index="0"><code>/* Hide keyboard/copy hint when embedded in an iframe */ .palette-page.embedded .kbd-hint { display: none; } /* Hide keyboard hint on touch devices (mobile/tablet) */ @media (hover: none), (pointer: coarse) { .palette-page .kbd-hint { display: none; } } /* ------- ensure palette colors are immune to dark mode/forced adjustments ------- */ .palette-page .color-columns, .palette-page .color-col, .palette-page .color-col * { color-scheme: light; /* don’t auto-adjust UI colors */ forced-color-adjust: none; /* prevent UA forced color modes */ mix-blend-mode: normal; /* no blending tricks */ background-blend-mode: normal; filter: none; /* avoid accidental filters */ } /* ------- info overlay ------- */ .color-col .info{ position:absolute; inset:auto 0 clamp(1rem,4vh,2.5rem) 0; text-align:center; color:#fff; font-weight:600; font-size:clamp(.9rem,2vw,1.1rem); line-height:1.35; pointer-events:auto; user-select:none; display:flex; flex-direction:column; align-items:center; gap:.35rem; padding: 0 .35rem; /* tiny horizontal padding so text doesn’t touch edges */ } .color-col .hex{opacity:.95} .color-col .name{opacity:.8} /* ------- lock button (now inside overlay, above hex) ------- */ .lock-btn{ display:inline-flex; align-items:center; justify-content:center; width:2.1rem; height:2.1rem; border-radius:999px; border:2px solid rgba(255,255,255,.85); background:transparent; color:#fff; cursor:pointer; transition:.2s ease; pointer-events:auto; } .lock-btn:hover{background:rgba(255,255,255,.15)} .color-col[data-locked=&quot;true&quot;] .lock-btn{background:rgba(255,255,255,.95); color:#000; border-color:transparent} .lock-btn:focus{outline:2px solid rgba(255,255,255,.6); outline-offset:2px} /* ------- generate button ------- */ #generateBtn{ padding:.6em 1.6em; font-size:1rem; cursor:pointer; pointer-events:auto; } #generateBtn:focus-visible { outline: 2px solid #000; /* ensure keyboard focus is clearly visible */ outline-offset: 2px; } </code></pre> "></#data>"></#data>"></#data>"></#data>"></#data></style> <site-header></site-header> <div> <div> <div>Space to generate • 1–4 to lock</div> <button>Generate</button> </div> <div> <div> <div> <button>🔒</button> <div></div> <div></div> </div> </div> <div> <div> <button>🔒</button> <div></div> <div></div> </div> </div> <div> <div> <button>🔒</button> <div></div> <div></div> </div> </div> <div> <div> <button>🔒</button> <div></div> <div></div> </div> </div> </div> </div> <script></script> <script></script> <script></script> <site-footer></site-footer> import { BLACK_TO_BLACK, hexFromName, nameFromHex } from '../data/black-colors.js'; /* ----- helpers ------------------------------------------------------- */ function randomShade () { // Bias toward darker: square the RNG, cap to 0–63 (quarter range) const v = Math.floor(Math.pow(Math.random(), 2) * 64); const hex = v.toString(16).padStart(2, '0'); return #${hex}${hex}${hex}.toUpperCase(); } function normalizeHex6 (s) { if (!s) return null; const raw = s.startsWith('#') ? s.slice(1) : s; if (!/^[0-9a-fA-F]{6}$/.test(raw)) return null; return #${raw.toUpperCase()}; } // Determine if background is light enough to require dark (black) text function isLightBackground(hex) { if (!hex) return false; const raw = hex.startsWith('#') ? hex.slice(1) : hex; if (raw.length !== 6) return false; const r = parseInt(raw.slice(0, 2), 16); const g = parseInt(raw.slice(2, 4), 16); const b = parseInt(raw.slice(4, 6), 16); // Perceived luminance (Rec. 601) vs a midpoint threshold; shades are grayscale but this is robust const y = 0.299 * r + 0.587 * g + 0.114 * b; return y >= 140; // around mid-gray; ensures white flips to black text } function applyContrastStyles(col, hex) { const info = col.querySelector('.info'); const btn = col.querySelector('.lock-btn'); const locked = col.dataset.locked === 'true'; const lightBg = isLightBackground(hex); // Text color for overlay info.style.color = lightBg ? '#000' : '#FFF'; // Adjust lock button appearance only when not locked; when locked, let CSS style take precedence if (!locked) { btn.style.color = lightBg ? '#000' : '#FFF'; btn.style.borderColor = lightBg ? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.85)'; btn.style.background = 'transparent'; } else { // Clear inline to allow CSS state styles to apply btn.style.removeProperty('color'); btn.style.removeProperty('border-color'); btn.style.removeProperty('background'); } } // Session-scoped usage counter (not persisted). const sessionUsage = Object.create(null); function bumpUsage (usage, hex, delta = 1) { const k = String(hex || '').toUpperCase(); if (!k || !/^#[0-9A-F]{6}$/.test(k)) return; usage[k] = (usage[k] || 0) + delta; } // Build unique hex shades: prefer dictionary entries, then random unique grayscale if needed. // Bias selection toward hexes that have been used less frequently in this session. function buildUniqueHexes (needed, excludeHexes = new Set(), usage = {}, bias = 1.0) { const out = []; const used = new Set([...excludeHexes].map(h => String(h).toUpperCase())); // 1) Build candidate list from NAME_DICT, dedup by resulting hex const candidateSet = new Set(); const candidates = []; for (const name of Object.keys(BLACK_TO_BLACK)) { const hex = hexFromName(name)?.toUpperCase(); if (!hex) continue; if (used.has(hex)) continue; // avoid anything already used/excluded if (candidateSet.has(hex)) continue; // many names map to same grayscale hex candidateSet.add(hex); const count = usage[hex] || 0; // Higher score -> more likely to be picked. Downweight by past usage. const score = Math.random() / (1 + count * Math.max(0, bias)); candidates.push({ hex, score }); } // Randomized, usage-aware ordering candidates.sort((a, b) => b.score - a.score); // 2) Take from candidates until satisfied or exhausted for (const c of candidates) { if (out.length >= needed) break; if (used.has(c.hex)) continue; // redundant, but safe used.add(c.hex); out.push(c.hex); } // 3) if still short, generate random grayscale shades avoiding used while (out.length < needed) { const hex = randomShade().toUpperCase(); if (used.has(hex)) continue; used.add(hex); out.push(hex); } return out; } function columns () { return [...document.querySelectorAll('.color-col')]; } function setColumnShade (col, hex, setName = true, name = null) { const info = col.querySelector('.info'); col.style.background = hex; col.dataset.shade = hex; info.querySelector('.hex').textContent = hex; if (setName) { info.querySelector('.name').textContent = name ?? nameFromHex(hex) ?? ''; } applyContrastStyles(col, hex); } function updateHashFromDOM () { const shades = columns().map(c => (c.dataset.shade || '#000000').slice(1)); location.hash = shades.join('-'); } function parseHash () { const h = location.hash.replace(/^#/, ''); if (!h) return null; const parts = h.split('-').map(normalizeHex6).filter(Boolean); return parts.length ? parts : null; } function applyShades (shades, overwriteLocked = false) { const cols = columns(); const count = Math.min(cols.length, shades.length); for (let i = 0; i < count; i++) { const col = cols[i]; const locked = col.dataset.locked === 'true'; if (locked && !overwriteLocked) continue; setColumnShade(col, shades[i], true); } updateHashFromDOM(); } function toggleLock (col) { const locked = col.dataset.locked === 'true'; const next = (!locked).toString(); col.dataset.locked = next; const btn = col.querySelector('.lock-btn'); if (btn) { btn.setAttribute('aria-pressed', next); const idx = (parseInt(col.dataset.index, 10) || 0) + 1; btn.title = (next === 'true') ? Unlock (${idx}) : Lock (${idx}); } // Re-apply contrast styling since lock visuals may change const hex = col.dataset.shade || '#000000'; applyContrastStyles(col, hex); } function copyToClipboard (text) { if (navigator.clipboard && navigator.clipboard.writeText) { return navigator.clipboard.writeText(text); } return new Promise((resolve, reject) => { const ta = document.createElement('textarea'); ta.value = text; ta.style.position = 'fixed'; ta.style.opacity = '0'; document.body.appendChild(ta); ta.focus(); ta.select(); try { document.execCommand('copy'); resolve(); } catch (e) { reject(e); } finally { document.body.removeChild(ta); } }); } function generate ({respectLocks = true} = {}) { const cols = columns(); // Determine targets and exclusion set const targets = respectLocks ? cols.filter(c => c.dataset.locked !== 'true') : cols; const exclude = new Set(); if (respectLocks) { cols.forEach(c => { if (c.dataset.locked === 'true' && c.dataset.shade) exclude.add(String(c.dataset.shade).toUpperCase()); }); } const toFill = targets.length; const newHexes = buildUniqueHexes(toFill, exclude, sessionUsage, 1.0); let idx = 0; targets.forEach(col => { const hex = newHexes[idx++]; const resolvedName = nameFromHex(hex) ?? ''; setColumnShade(col, hex, true, resolvedName); bumpUsage(sessionUsage, hex, 1); }); updateHashFromDOM(); } function attachEvents (opts = { embedded: false }) { const cols = columns(); // Lock buttons cols.forEach(col => { const btn = col.querySelector('.lock-btn'); if (!btn) return; btn.addEventListener('click', (e) => { e.stopPropagation(); toggleLock(col); }); }); // Click to copy cols.forEach(col => { col.addEventListener('click', async (e) => { if (e.target.closest && e.target.closest('.lock-btn')) return; const hexEl = col.querySelector('.hex'); const nameEl = col.querySelector('.name'); const hex = hexEl.textContent; const prev = nameEl.textContent; try { await copyToClipboard(hex); nameEl.textContent = 'Copied!'; } catch { nameEl.textContent = 'Copy failed'; } finally { setTimeout(() => { nameEl.textContent = prev; }, 800); } }); }); // Keyboard shortcuts (skip when embedded) if (!opts.embedded) { const handleKeyDown = (e) => { const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : ''; if (tag === 'input' || tag === 'textarea' || e.isComposing) return; if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); generate({respectLocks: true}); return; } const max = columns().length; if (/^[1-9]$/.test(e.key)) { const n = parseInt(e.key, 10); if (n >= 1 && n <= max) { const colsArr = columns(); const col = colsArr[n - 1]; if (col) toggleLock(col); } } }; // Listen on window to catch global key events when the window is focused window.addEventListener('keydown', handleKeyDown); } // Generate button const btn = document.getElementById('generateBtn'); if (btn) btn.addEventListener('click', () => generate({respectLocks: true})); // React to hash changes (e.g., back/forward) window.addEventListener('hashchange', () => { const parts = parseHash(); if (parts) applyShades(parts, false); }); } function init () { const embedded = (() => { try { return window.self !== window.top; } catch { return true; } })(); // Tag root element to enable CSS overrides when embedded const root = document.documentElement; if (embedded) root.classList.add('embedded'); // If embedded, ensure nothing is auto-focused (e.g., the Generate button) if (embedded) { const gb = document.getElementById('generateBtn'); if (gb) { gb.removeAttribute('autofocus'); if (document.activeElement === gb) { try { gb.blur(); } catch { /* noop */ } } } } const cols = columns(); cols.forEach((col, i) => { col.dataset.index = String(i); col.dataset.locked = col.dataset.locked || 'false'; if (embedded) col.removeAttribute('title'); // avoid implying copy hint inside iframes }); // Ensure the page is focusable so key events are captured without a click (not when embedded) const ensureFocus = () => { if (embedded) return; if (document.visibilityState && document.visibilityState !== 'visible') return; const container = document.querySelector('.container'); const target = container || document.body; if (!target) return; if (!target.hasAttribute('tabindex')) target.setAttribute('tabindex', '-1'); try { target.focus({ preventScroll: true }); } catch { /* noop / } try { window.focus(); } catch { / noop / } // Fallback: if focus didn't stick, try body on next tick requestAnimationFrame(() => { const ae = document.activeElement; if (!ae || ae === document.body || ae === document.documentElement) { try { if (!document.body.hasAttribute('tabindex')) document.body.setAttribute('tabindex', '-1'); document.body.focus({ preventScroll: true }); } catch { / noop */ } } }); }; // Try focusing ASAP and also when page becomes fully shown if (!embedded) { // After DOM is ready requestAnimationFrame(ensureFocus); // When page loaded (all resources) or restored from bfcache window.addEventListener('load', ensureFocus, { once: true }); window.addEventListener('pageshow', (e) => { if (e.persisted) ensureFocus(); }); document.addEventListener('visibilitychange', ensureFocus); } attachEvents({ embedded }); const fromHash = parseHash(); if (fromHash) { const need = cols.length; const base = fromHash.slice(0, need); const exclude = new Set(base.map(h => String(h).toUpperCase())); const extrasNeeded = Math.max(0, need - base.length); if (extrasNeeded > 0) { const extraHexes = buildUniqueHexes(extrasNeeded, exclude, sessionUsage, 1.0); applyShades([...base, ...extraHexes], true); } else { applyShades(base, true); } } else { generate({respectLocks: false}); } // Ensure initial contrast styles are applied columns().forEach(col => applyContrastStyles(col, col.dataset.shade || '#000000')); } // Boot if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }

<html lang="en" class="palette-page rtiknur idc0_343" data-darkreader-mode="dynamic" data-darkreader-scheme="dark" data-darkreader-proxy-injected="true" style="--header-height: 65px; --footer-height: 70px; --safe-top: 0px; --safe-bottom: 0px;" data-theme="dark" data-copytables-uid="u08382246411573"><head><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--user-agent" media="screen">@layer {
html {
    background-color: var(--darkreader-background-ffffff, #202223) !important;
}
html {
    color-scheme: dark !important;
}
iframe {
    color-scheme: dark !important;
}
html, body {
    background-color: var(--darkreader-background-ffffff, #202223);
}
html, body {
    border-color: var(--darkreader-border-4c4c4c, #6a6359);
    color: var(--darkreader-text-000000, #c9c7c5);
}
a {
    color: var(--darkreader-text-0040ff, #3682db);
}
table {
    border-color: var(--darkreader-border-808080, #515659);
}
mark {
    color: var(--darkreader-text-000000, #c9c7c5);
}
::placeholder {
    color: var(--darkreader-text-a9a9a9, #9d978f);
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: var(--darkreader-background-faffbd, #41440d) !important;
    color: var(--darkreader-text-000000, #c9c7c5) !important;
}
* {
    scrollbar-color: var(--darkreader-background-b0b0b0, #45494b) var(--darkreader-background-f1f1f1, #27292a);
}
::selection {
    background-color: var(--darkreader-background-0060d4, #0d4b96) !important;
    color: var(--darkreader-text-ffffff, #c9c7c5) !important;
}
::-moz-selection {
    background-color: var(--darkreader-background-0060d4, #0d4b96) !important;
    color: var(--darkreader-text-ffffff, #c9c7c5) !important;
}
}</style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen">.jfk-bubble.gtx-bubble, .captcheck_answer_label > input + img, span#closed_text > img[src^="https://www.gstatic.com/images/branding/googlelogo"], span[data-href^="https://www.hcaptcha.com/"] > #icon, img.Wirisformula, a[data-testid="headerMediumLogo"]>svg, .d2l-navigation-link-image-container, .d2l-iframe-loading-container {
    filter: invert(100%) hue-rotate(180deg) brightness(90%) contrast(80%) !important;
}</style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}
[data-darkreader-inline-stopcolor] {
  stop-color: var(--darkreader-inline-stopcolor) !important;
}
[data-darkreader-inline-bg] {
  background: var(--darkreader-inline-bg) !important;
}
[data-darkreader-inline-border-short] {
  border: var(--darkreader-inline-border-short) !important;
}
[data-darkreader-inline-border-bottom-short] {
  border-bottom: var(--darkreader-inline-border-bottom-short) !important;
}
[data-darkreader-inline-border-left-short] {
  border-left: var(--darkreader-inline-border-left-short) !important;
}
[data-darkreader-inline-border-right-short] {
  border-right: var(--darkreader-inline-border-right-short) !important;
}
[data-darkreader-inline-border-top-short] {
  border-top: var(--darkreader-inline-border-top-short) !important;
}
[data-darkreader-inline-invert] {
    filter: invert(100%) hue-rotate(180deg);
}</style><style class="darkreader darkreader--variables" media="screen">:root {
   --darkreader-neutral-background: var(--darkreader-background-ffffff, #202223);
   --darkreader-neutral-text: var(--darkreader-text-000000, #c9c7c5);
   --darkreader-selection-background: var(--darkreader-background-0060d4, #0d4b96);
   --darkreader-selection-text: var(--darkreader-text-ffffff, #c9c7c5);
}</style><style class="darkreader darkreader--root-vars" media="screen"></style>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Palette Generator</title>
  <link rel="stylesheet" href="/styles/main.css"><style class="darkreader darkreader--sync" media="screen"></style>
  <style>
    /* ------- layout ------- */
    body {display:flex; flex-direction:column; min-height:100dvh;}
    .container{flex:1 1 auto; display:flex; flex-direction:column; padding:0; gap:0; min-height:0; position:relative; align-items:stretch; max-width:100vw;}
    .controls{position:absolute; top:0.5rem; left:50%; transform:translateX(-50%); z-index:3; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:.4rem; padding:0; pointer-events:none;}
    .kbd-hint{color:#666; font-size:.95rem; user-select:none; pointer-events:none;}
    .color-columns{flex:1 1 auto; display:flex; min-height:0; min-width:0; flex-direction: row; width:100%;}
    .color-col   {flex:1; position:relative; cursor:copy; min-width:0;}

    .palette-page.embedded .kbd-hint { display: none; }
    @media (hover: none), (pointer: coarse) { .palette-page .kbd-hint { display: none; } }

    /* Prevent dark-mode/forced adjustments on palette UI */
    .palette-page .color-columns,
    .palette-page .color-col,
    .palette-page .color-col * {
      color-scheme: light;
      forced-color-adjust: none;
      mix-blend-mode: normal;
      background-blend-mode: normal;
      filter: none;
    }

    .color-col .info{ position:absolute; inset:auto 0 clamp(1rem,4vh,2.5rem) 0; text-align:center; color:#fff; font-weight:600; font-size:clamp(.9rem,2vw,1.1rem); line-height:1.35; pointer-events:auto; user-select:none; display:flex; flex-direction:column; align-items:center; gap:.35rem; padding:0 .35rem; }
    .color-col .hex{opacity:.95}
    .color-col .name{opacity:.8}

    .lock-btn{ display:inline-flex; align-items:center; justify-content:center; width:2.1rem; height:2.1rem; border-radius:999px; border:2px solid rgba(255,255,255,.85); background:transparent; color:#fff; cursor:pointer; transition:.2s ease; pointer-events:auto; }
    .lock-btn:hover{background:rgba(255,255,255,.15)}
    .color-col[data-locked="true"] .lock-btn{background:rgba(255,255,255,.95); color:#000; border-color:transparent}
    .lock-btn:focus{outline:2px solid rgba(255,255,255,.6); outline-offset:2px}

    #generateBtn{ padding:.6em 1.6em; font-size:1rem; cursor:pointer; pointer-events:auto; }
    #generateBtn:focus-visible { outline:2px solid #000; outline-offset:2px; }
  </style><style class="darkreader darkreader--sync" media="screen"></style>
<meta name="darkreader" content="9e4ef77b0f7b487e812a9544a18bdcaf"><style class="darkreader darkreader--override" media="screen">.vimvixen-hint {
    background-color: var(--darkreader-background-ffd76e, #614a0d) !important;
    border-color: var(--darkreader-background-c59d00, #8d730d) !important;
    color: var(--darkreader-text-302505, #bbb8b4) !important;
}
#vimvixen-console-frame {
    color-scheme: light !important;
}
::placeholder {
    opacity: 0.5 !important;
}
#edge-translate-panel-body,
.MuiTypography-body1,
.nfe-quote-text {
    color: var(--darkreader-neutral-text) !important;
}
gr-main-header {
    background-color: var(--darkreader-background-add8e6, #234854) !important;
}
.tou-z65h9k,
.tou-mignzq,
.tou-1b6i2ox,
.tou-lnqlqk {
    background-color: var(--darkreader-neutral-background) !important;
}
.tou-75mvi {
    background-color: var(--darkreader-background-cfecf5, #193c46) !important;
}
.tou-ta9e87,
.tou-1w3fhi0,
.tou-1b8t2us,
.tou-py7lfi,
.tou-1lpmd9d,
.tou-1frrtv8,
.tou-17ezmgn {
    background-color: var(--darkreader-background-f5f5f5, #252727) !important;
}
.tou-uknfeu {
    background-color: var(--darkreader-background-faedda, #433014) !important;
}
.tou-6i3zyv {
    background-color: var(--darkreader-background-85c3d8, #2a5867) !important;
}
div.mermaid-viewer-control-panel .btn {
    background-color: var(--darkreader-neutral-background);
    fill: var(--darkreader-neutral-text);
}
svg g rect.er {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.entityBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxOdd {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.er.attributeBoxEven {
    fill: var(--darkreader-selection-background);
    fill-opacity: 0.8 !important;
}
svg rect.er.relationshipLabelBox {
    fill: var(--darkreader-neutral-background) !important;
}
svg g g.nodes rect,
svg g g.nodes polygon {
    fill: var(--darkreader-neutral-background) !important;
}
svg g rect.task {
    fill: var(--darkreader-selection-background) !important;
}
svg line.messageLine0,
svg line.messageLine1 {
    stroke: var(--darkreader-neutral-text) !important;
}
div.mermaid .actor {
    fill: var(--darkreader-neutral-background) !important;
}
mitid-authenticators-code-app > .code-app-container {
    background-color: white !important;
    padding-top: 1rem;
}
iframe#unpaywall[src$="unpaywall.html"] {
    color-scheme: light !important;
}
select {
    --darkreader-bg--form-control-background-color: rgba(22, 22, 22, 0) !important;
}
select * {
    background-color: var(--darkreader-neutral-background) !important;
}
body#tumblr {
    --darkreader-bg--secondary-accent: 31, 32, 34 !important;
    --darkreader-bg--white: 23, 23, 23 !important;
    --darkreader-text--black: 228, 224, 218 !important;
}
:host {
    --d2l-border-color: var(--darkreader-bg--d2l-color-gypsum) !important;
    --d2l-button-icon-background-color-hover: var(--darkreader-bg--d2l-color-gypsum) !important;
    --d2l-color-ferrite: var(--darkreader-neutral-text) !important;
    --d2l-color-sylvite: var(--darkreader-bg--d2l-color-sylvite) !important;
    --d2l-dropdown-background-color: var(--darkreader-neutral-background) !important;
    --d2l-dropdown-border-color: var(--darkreader-border--d2l-color-mica) !important;
    --d2l-input-backgroud-color: var(--darkreader-neutral-background) !important;
    --d2l-menu-border-color: var(--darkreader-bg--d2l-color-gypsum) !important;
    --d2l-tooltip-background-color: var(--darkreader-neutral-background) !important;
    --d2l-tooltip-border-color: var(--darkreader-bg--d2l-color-gypsum) !important;
}
:host([_floating]) .d2l-floating-buttons-container {
    background-color: var(--darkreader-neutral-background) !important;
    border-top-color: var(--darkreader-border--d2l-color-mica) !important;
    opacity: 0.88 !important;
}
d2l-card {
    background: var(--darkreader-neutral-background) !important;
    border-color: var(--darkreader-border--d2l-color-gypsum) !important;
}
d2l-dropdown-content > div,
d2l-menu-item {
    background-color: var(--darkreader-neutral-background) !important;
    border-radius: 10px !important;
}
d2l-empty-state-simple {
    border-color: var(--darkreader-bg--d2l-color-gypsum) !important;
}
.d2l-button-filter > ul > li > a.vui-button {
    border-color: var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-label-text:has(.d2l-button-subtle-content):hover,
.d2l-label-text:has(.d2l-button-subtle-content):focus,
.d2l-label-text:has(.d2l-button-subtle-content):active {
    background-color: var(--darkreader-bg--d2l-color-gypsum) !important;
}
.d2l-navigation-centerer {
    color: inherit !important;
}
.d2l-tabs-layout {
    border-color: var(--darkreader-border--d2l-color-gypsum) !important;
}
.d2l-input,
.d2l-calendar-date,
.d2l-htmleditor-container {
    background-color: var(--darkreader-neutral-background) !important;
}
.d2l-collapsible-panel {
    border: 1px solid var(--darkreader-border--d2l-color-mica) !important;
    border-radius: 0.4rem !important;
}
.d2l-collapsible-panel-divider {
    border-bottom: 1px solid var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-w2d-flex {
    border-bottom: 2px solid var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-collapsible-panel scrolled,
.d2l-collapsible-panel-header,
.d2l-w2d-collection-fixed {
    background-color: var(--darkreader-neutral-background) !important;
}
.d2l-loading-spinner-bg {
    fill: var(--darkreader-bg--d2l-color-gypsum) !important;
}
.d2l-loading-spinner-bg-stroke {
    stroke: var(--darkreader-border--d2l-color-mica) !important;
}
.d2l-loading-spinner-wrapper svg path,
.d2l-loading-spinner-wrapper svg circle {
    fill: var(--darkreader-neutral-background) !important;
}</style></head>
<body>
  <site-header><nav class="topnav" style="flex-wrap: nowrap;"><a href="/" data-path="/">Home</a><a href="/contact/" data-path="/contact/">Contact</a><a href="/about/" data-path="/about/">About</a><a href="/map/" data-path="/map/">Map</a></nav></site-header>

  <div class="container" tabindex="-1">
    <div class="controls">
      <div class="kbd-hint">Space to generate • 1–4 to lock</div>
      <button id="generateBtn" class="button">Generate</button>
    </div>
    <div class="color-columns">
      <div class="color-col" id="col0" data-index="0" data-locked="false" title="Click to copy hex" data-shade="#000000" style="background: rgb(0, 0, 0); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: var(--darkreader-background-000000, #0d0d0d);" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">
        <div class="info" style="color: rgb(255, 255, 255); --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5);" data-darkreader-inline-color="">
          <button class="lock-btn" aria-pressed="false" aria-label="Lock column 1" title="Lock (1)" style="color: rgb(255, 255, 255); border-color: rgba(255, 255, 255, 0.85); background: transparent; --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5); --darkreader-inline-border-top: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-right: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-bottom: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-left: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: transparent;" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">🔒</button>
          <div class="hex">#000000</div>
          <div class="name"></div>
        </div>
      </div>
      <div class="color-col" id="col1" data-index="1" data-locked="false" title="Click to copy hex" data-shade="#131313" style="background: rgb(19, 19, 19); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: var(--darkreader-background-131313, #18191a);" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">
        <div class="info" style="color: rgb(255, 255, 255); --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5);" data-darkreader-inline-color="">
          <button class="lock-btn" aria-pressed="false" aria-label="Lock column 2" title="Lock (2)" style="color: rgb(255, 255, 255); border-color: rgba(255, 255, 255, 0.85); background: transparent; --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5); --darkreader-inline-border-top: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-right: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-bottom: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-left: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: transparent;" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">🔒</button>
          <div class="hex">#131313</div>
          <div class="name"></div>
        </div>
      </div>
      <div class="color-col" id="col2" data-index="2" data-locked="false" title="Click to copy hex" data-shade="#1F1F1F" style="background: rgb(31, 31, 31); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: var(--darkreader-background-1f1f1f, #1f2122);" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">
        <div class="info" style="color: rgb(255, 255, 255); --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5);" data-darkreader-inline-color="">
          <button class="lock-btn" aria-pressed="false" aria-label="Lock column 3" title="Lock (3)" style="color: rgb(255, 255, 255); border-color: rgba(255, 255, 255, 0.85); background: transparent; --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5); --darkreader-inline-border-top: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-right: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-bottom: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-left: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: transparent;" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">🔒</button>
          <div class="hex">#1F1F1F</div>
          <div class="name"></div>
        </div>
      </div>
      <div class="color-col" id="col3" data-index="3" data-locked="false" title="Click to copy hex" data-shade="#181818" style="background: rgb(24, 24, 24); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: var(--darkreader-background-181818, #1b1d1d);" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">
        <div class="info" style="color: rgb(255, 255, 255); --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5);" data-darkreader-inline-color="">
          <button class="lock-btn" aria-pressed="false" aria-label="Lock column 4" title="Lock (4)" style="color: rgb(255, 255, 255); border-color: rgba(255, 255, 255, 0.85); background: transparent; --darkreader-inline-color: var(--darkreader-text-ffffff, #c9c7c5); --darkreader-inline-border-top: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-right: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-bottom: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-border-left: var(--darkreader-border-ffffffd9, rgba(52, 55, 56, 0.85)); --darkreader-inline-bgimage: initial; --darkreader-inline-bgcolor: transparent;" data-darkreader-inline-color="" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left="" data-darkreader-inline-bgimage="" data-darkreader-inline-bgcolor="">🔒</button>
          <div class="hex">#181818</div>
          <div class="name"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/scripts/core/main.js"></script>
  <script type="module" src="/scripts/components/header.js"></script>
  <script type="module" src="./app.js"></script>
  <script type="module" src="/scripts/components/footer.js"></script>

  <site-footer>
      <style>
        :host {
          display: block;
          font: 14px/1.4 system-ui, -apple-system;
          /* Default spacing above footer; JS will override via gap-top attribute */
          margin-top: 0;
        }
        footer {
          display: flex;
          flex-wrap: wrap;
          justify-content: center;
          align-items: flex-end; /* Align items to the bottom */
          gap: 0; /* Let separators handle spacing */
          /* ideal 10vw each side, max 4rem, min .5rem */
          padding-inline: clamp(.5rem, 10vw, 6rem);
          /* Defaults: zero top pad; JS can override via pad-top attribute */
          padding-top: 0;
          /* keep bottom pad constant (was overridable via CSS var) */
          padding-bottom: clamp(0.2rem, 1vw, 1rem);
          box-sizing: border-box;
        }
        .group {
          display: flex;
          white-space: nowrap;
          gap: 0; /* Remove gap, use margin on separator */
          align-items: center;
        }
        .group .item:not(:last-child)::after {
          content: '|';
          margin: 0 0.4rem; /* Symmetrical margin */
          user-select: none;
        }
        /* conditional “|” before second group */
        .group.second::before {
          content: '|';
          margin: 0 0.4rem; /* Symmetrical margin */
          user-select: none;
          display: none;
        }
        .group.second.inline-sep::before {
          display: block;
        }
      </style><style class="darkreader darkreader--sync" media="screen"></style>
    <footer><div class="group first"><a class="item" href="/terms/">Terms&nbsp;of&nbsp;Use</a><a class="item" href="/privacy/">Privacy&nbsp;Policy</a><a class="item" href="/contact/">Contact</a></div><div class="group second"><a class="item" href="/this-site-is-written-by-ai/">This site is written by AI</a><a class="item" href="/copyright/">© 2025 Edward Coventry</a></div></footer></site-footer>



</body></html>



<!doctype html>
<html lang="en" class="palette-page">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Palette Generator</title>
    <style>
      /* ------- layout ------- */
      :root { color-scheme: light; }
      body { margin: 0; display: flex; flex-direction: column; min-height: 100dvh; }
      .container { flex: 1 1 auto; display: flex; flex-direction: column; padding: 0; gap: 0; min-height: 0; position: relative; align-items: stretch; max-width: 100vw; }

      .controls {
        position: absolute; top: 0.5rem; left: 50%; transform: translateX(-50%); z-index: 3;
        display: flex; flex-direction: column; align-items: center; gap: .4rem; pointer-events: none;
      }
      .controls * { pointer-events: auto; }
      .kbd-hint { color: #666; font-size: .95rem; user-select: none; }

      .color-columns { flex: 1 1 auto; display: flex; min-height: 0; min-width: 0; width: 100%; }
      .color-col { flex: 1; position: relative; cursor: copy; min-width: 0; }

      /* Hide keyboard/copy hint when embedded or on touch */
      .palette-page.embedded .kbd-hint { display: none; }
      @media (hover: none), (pointer: coarse) { .palette-page .kbd-hint { display: none; } }

      /* Keep palette immune to UA forced color modes */
      .palette-page .color-columns,
      .palette-page .color-col,
      .palette-page .color-col * {
        color-scheme: light; forced-color-adjust: none; mix-blend-mode: normal; background-blend-mode: normal; filter: none;
      }

      /* ------- info overlay ------- */
      .color-col .info {
        position: absolute; inset: auto 0 clamp(1rem, 4vh, 2.5rem) 0; text-align: center;
        color: #fff; font-weight: 600; font-size: clamp(.9rem, 2vw, 1.1rem); line-height: 1.35;
        user-select: none; display: flex; flex-direction: column; align-items: center; gap: .35rem; padding: 0 .35rem;
      }
      .color-col .hex { opacity: .95; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      .color-col .name { opacity: .8; }

      /* ------- lock button ------- */
      .lock-btn {
        display: inline-flex; align-items: center; justify-content: center;
        width: 2.1rem; height: 2.1rem; border-radius: 999px;
        border: 2px solid rgba(255,255,255,.85); background: transparent; color: #fff;
        cursor: pointer; transition: .2s ease;
      }
      .lock-btn:hover { background: rgba(255,255,255,.15); }
      .color-col[data-locked="true"] .lock-btn { background: rgba(255,255,255,.95); color: #000; border-color: transparent; }
      .lock-btn:focus { outline: 2px solid rgba(255,255,255,.6); outline-offset: 2px; }

      /* ------- generate button ------- */
      #generateBtn { padding: .6em 1.6em; font-size: 1rem; cursor: pointer; }
      #generateBtn:focus-visible { outline: 2px solid #000; outline-offset: 2px; }
    </style>
  </head>
  <body>
    <site-header></site-header>

    <main class="container">
      <div class="controls">
        <div class="kbd-hint">Space to generate • 1–4 to lock</div>
        <button id="generateBtn" type="button" aria-label="Generate palette">Generate</button>
      </div>

      <div class="color-columns" aria-live="polite">
        <!-- Column 1 -->
        <div class="color-col" data-locked="false" data-index="0" title="Click to copy">
          <div class="info">
            <button class="lock-btn" type="button" aria-pressed="false" title="Lock (1)">🔒</button>
            <div class="hex">#000000</div>
            <div class="name"></div>
          </div>
        </div>
        <!-- Column 2 -->
        <div class="color-col" data-locked="false" data-index="1" title="Click to copy">
          <div class="info">
            <button class="lock-btn" type="button" aria-pressed="false" title="Lock (2)">🔒</button>
            <div class="hex">#000000</div>
            <div class="name"></div>
          </div>
        </div>
        <!-- Column 3 -->
        <div class="color-col" data-locked="false" data-index="2" title="Click to copy">
          <div class="info">
            <button class="lock-btn" type="button" aria-pressed="false" title="Lock (3)">🔒</button>
            <div class="hex">#000000</div>
            <div class="name"></div>
          </div>
        </div>
        <!-- Column 4 -->
        <div class="color-col" data-locked="false" data-index="3" title="Click to copy">
          <div class="info">
            <button class="lock-btn" type="button" aria-pressed="false" title="Lock (4)">🔒</button>
            <div class="hex">#000000</div>
            <div class="name"></div>
          </div>
        </div>
      </div>
    </main>

    <site-footer></site-footer>

    <script type="module">
      import { BLACK_TO_BLACK, hexFromName, nameFromHex } from '../data/black-colors.js';

      function randomShade() {
        const v = Math.floor(Math.pow(Math.random(), 2) * 64);
        const hex = v.toString(16).padStart(2, '0');
        return `#${hex}${hex}${hex}`.toUpperCase();
      }

      function normalizeHex6(s) {
        if (!s) return null;
        const raw = s.startsWith('#') ? s.slice(1) : s;
        if (!/^[0-9a-fA-F]{6}$/.test(raw)) return null;
        return `#${raw.toUpperCase()}`;
      }

      function isLightBackground(hex) {
        if (!hex) return false;
        const raw = hex.startsWith('#') ? hex.slice(1) : hex;
        if (raw.length !== 6) return false;
        const r = parseInt(raw.slice(0, 2), 16);
        const g = parseInt(raw.slice(2, 4), 16);
        const b = parseInt(raw.slice(4, 6), 16);
        const y = 0.299 * r + 0.587 * g + 0.114 * b;
        return y >= 140;
      }

      function applyContrastStyles(col, hex) {
        const info = col.querySelector('.info');
        const btn = col.querySelector('.lock-btn');
        const locked = col.dataset.locked === 'true';
        const lightBg = isLightBackground(hex);
        if (info) info.style.color = lightBg ? '#000' : '#FFF';
        if (!btn) return;
        if (!locked) {
          btn.style.color = lightBg ? '#000' : '#FFF';
          btn.style.borderColor = lightBg ? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.85)';
          btn.style.background = 'transparent';
        } else {
          btn.style.removeProperty('color');
          btn.style.removeProperty('border-color');
          btn.style.removeProperty('background');
        }
      }

      const sessionUsage = Object.create(null);
      function bumpUsage(usage, hex, delta = 1) {
        const k = String(hex || '').toUpperCase();
        if (!k || !/^#[0-9A-F]{6}$/.test(k)) return;
        usage[k] = (usage[k] || 0) + delta;
      }

      function buildUniqueHexes(needed, excludeHexes = new Set(), usage = {}, bias = 1.0) {
        const out = [];
        const used = new Set([...excludeHexes].map(h => String(h).toUpperCase()));
        const candidateSet = new Set();
        const candidates = [];

        for (const name of Object.keys(BLACK_TO_BLACK)) {
          const hex = hexFromName(name)?.toUpperCase();
          if (!hex) continue;
          if (used.has(hex)) continue;
          if (candidateSet.has(hex)) continue;
          candidateSet.add(hex);
          const count = usage[hex] || 0;
          const score = Math.random() / (1 + count * Math.max(0, bias));
          candidates.push({ hex, score });
        }

        candidates.sort((a, b) => b.score - a.score);

        for (const c of candidates) {
          if (out.length >= needed) break;
          if (used.has(c.hex)) continue;
          used.add(c.hex);
          out.push(c.hex);
        }

        while (out.length < needed) {
          const hex = randomShade().toUpperCase();
          if (used.has(hex)) continue;
          used.add(hex);
          out.push(hex);
        }
        return out;
      }

      const qs = (sel, root = document) => root.querySelector(sel);
      const qsa = (sel, root = document) => [...root.querySelectorAll(sel)];
      const columns = () => qsa('.color-col');

      function setColumnShade(col, hex, setName = true, name = null) {
        const info = col.querySelector('.info');
        col.style.background = hex;
        col.dataset.shade = hex;
        info.querySelector('.hex').textContent = hex;
        if (setName) {
          info.querySelector('.name').textContent = name ?? nameFromHex(hex) ?? '';
        }
        applyContrastStyles(col, hex);
      }

      function updateHashFromDOM() {
        const shades = columns().map(c => (c.dataset.shade || '#000000').slice(1));
        location.hash = shades.join('-');
      }

      function parseHash() {
        const h = location.hash.replace(/^#/, '');
        if (!h) return null;
        const parts = h.split('-').map(normalizeHex6).filter(Boolean);
        return parts.length ? parts : null;
      }

      function applyShades(shades, overwriteLocked = false) {
        const cols = columns();
        const count = Math.min(cols.length, shades.length);
        for (let i = 0; i < count; i++) {
          const col = cols[i];
          const locked = col.dataset.locked === 'true';
          if (locked && !overwriteLocked) continue;
          setColumnShade(col, shades[i], true);
        }
        updateHashFromDOM();
      }

      function toggleLock(col) {
        const locked = col.dataset.locked === 'true';
        const next = (!locked).toString();
        col.dataset.locked = next;
        const btn = col.querySelector('.lock-btn');
        if (btn) {
          btn.setAttribute('aria-pressed', next);
          const idx = (parseInt(col.dataset.index, 10) || 0) + 1;
          btn.title = (next === 'true') ? `Unlock (${idx})` : `Lock (${idx})`;
        }
        const hex = col.dataset.shade || '#000000';
        applyContrastStyles(col, hex);
      }

      function copyToClipboard(text) {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text);
        }
        return new Promise((resolve, reject) => {
          const ta = document.createElement('textarea');
          ta.value = text; ta.style.position = 'fixed'; ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.focus(); ta.select();
          try { document.execCommand('copy'); resolve(); }
          catch (e) { reject(e); }
          finally { document.body.removeChild(ta); }
        });
      }

      function generate({ respectLocks = true } = {}) {
        const cols = columns();
        const targets = respectLocks ? cols.filter(c => c.dataset.locked !== 'true') : cols;
        const exclude = new Set();
        if (respectLocks) {
          cols.forEach(c => {
            if (c.dataset.locked === 'true' && c.dataset.shade) {
              exclude.add(String(c.dataset.shade).toUpperCase());
            }
          });
        }
        const toFill = targets.length;
        const newHexes = buildUniqueHexes(toFill, exclude, sessionUsage, 1.0);
        let idx = 0;
        targets.forEach(col => {
          const hex = newHexes[idx++];
          const resolvedName = nameFromHex(hex) ?? '';
          setColumnShade(col, hex, true, resolvedName);
          bumpUsage(sessionUsage, hex, 1);
        });
        updateHashFromDOM();
      }

      function attachEvents({ embedded = false } = {}) {
        const cols = columns();

        cols.forEach(col => {
          const btn = col.querySelector('.lock-btn');
          if (!btn) return;
          btn.addEventListener('click', e => { e.stopPropagation(); toggleLock(col); });
        });

        cols.forEach(col => {
          col.addEventListener('click', async e => {
            if (e.target.closest && e.target.closest('.lock-btn')) return;
            const hexEl = col.querySelector('.hex');
            const nameEl = col.querySelector('.name');
            const hex = hexEl.textContent;
            const prev = nameEl.textContent;
            try { await copyToClipboard(hex); nameEl.textContent = 'Copied!'; }
            catch { nameEl.textContent = 'Copy failed'; }
            finally { setTimeout(() => { nameEl.textContent = prev; }, 800); }
          });
        });

        if (!embedded) {
          const handleKeyDown = e => {
            const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
            if (tag === 'input' || tag === 'textarea' || e.isComposing) return;
            if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') { e.preventDefault(); generate({ respectLocks: true }); return; }
            const max = columns().length;
            if (/^[1-9]$/.test(e.key)) {
              const n = parseInt(e.key, 10);
              if (n >= 1 && n <= max) {
                const col = columns()[n - 1];
                if (col) toggleLock(col);
              }
            }
          };
          window.addEventListener('keydown', handleKeyDown);
        }

        const btn = document.getElementById('generateBtn');
        if (btn) btn.addEventListener('click', () => generate({ respectLocks: true }));

        window.addEventListener('hashchange', () => {
          const parts = parseHash();
          if (parts) applyShades(parts, false);
        });
      }

      function init() {
        const embedded = (() => { try { return window.self !== window.top; } catch { return true; } })();
        if (embedded) document.documentElement.classList.add('embedded');

        if (embedded) {
          const gb = document.getElementById('generateBtn');
          if (gb) { gb.removeAttribute('autofocus'); if (document.activeElement === gb) { try { gb.blur(); } catch {} } }
        }

        columns().forEach((col, i) => {
          col.dataset.index = String(i);
          col.dataset.locked = col.dataset.locked || 'false';
          if (embedded) col.removeAttribute('title');
        });

        const ensureFocus = () => {
          if (embedded) return;
          if (document.visibilityState && document.visibilityState !== 'visible') return;
          const target = document.querySelector('.container') || document.body;
          if (!target) return;
          if (!target.hasAttribute('tabindex')) target.setAttribute('tabindex', '-1');
          try { target.focus({ preventScroll: true }); } catch {}
          try { window.focus(); } catch {}
          requestAnimationFrame(() => {
            const ae = document.activeElement;
            if (!ae || ae === document.body || ae === document.documentElement) {
              try {
                if (!document.body.hasAttribute('tabindex')) document.body.setAttribute('tabindex', '-1');
                document.body.focus({ preventScroll: true });
              } catch {}
            }
          });
        };

        if (!embedded) {
          requestAnimationFrame(ensureFocus);
          window.addEventListener('load', ensureFocus, { once: true });
          window.addEventListener('pageshow', e => { if (e.persisted) ensureFocus(); });
          document.addEventListener('visibilitychange', ensureFocus);
        }

        attachEvents({ embedded });

        const fromHash = parseHash();
        if (fromHash) {
          const need = columns().length;
          const base = fromHash.slice(0, need);
          const exclude = new Set(base.map(h => String(h).toUpperCase()));
          const extrasNeeded = Math.max(0, need - base.length);
          if (extrasNeeded > 0) {
            const extraHexes = buildUniqueHexes(extrasNeeded, exclude, sessionUsage, 1.0);
            applyShades([...base, ...extraHexes], true);
          } else {
            applyShades(base, true);
          }
        } else {
          generate({ respectLocks: false });
        }

        columns().forEach(col => applyContrastStyles(col, col.dataset.shade || '#000000'));
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    </script>
  </body>
</html>



